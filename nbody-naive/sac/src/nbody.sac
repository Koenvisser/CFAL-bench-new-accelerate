use Array: all;
use Math: all;
use StdIO: all;
use Benchmarking: all;

#define EPSILON 0.000000001

inline
double[*] sum_outer( double[+] a)
{
  return with {
    ([0] <= iv < take([1], shape(a))): a[iv];
  } : fold(+, genarray(drop([1], shape(a)), 0d));
}

inline
double L2(double[.] x)
{
    return sqrt(sum(x * x));
}

inline
double[3] acceleration(double[3] pos1, double[3] pos2, double mass)
{
  dir = pos1 - pos2;
  return all(dir == 0.0) ? 
        [0.0, 0.0, 0.0] :
        mass * dir / (L2(dir) * L2(dir) * L2(dir));
}

inline
double[3] acceleration(double[3] pos, double[N, 3] positions, double[N] masses)
{
  /* With sum_outer we get a complaint for GPU 'not in perfect nested position' */
  acc = [0d, 0d, 0d];
  for (j = 0; j < N; j++) {
    acc += acceleration(pos, positions[j], masses[j]);
  }
  return acc;
//  return sum_outer({jv -> acceleration(pos, positions[jv], masses[jv])});
}

inline
double[3] accel(double[3] diff, double mass)
{
  return all(diff == 0.0) ?
          [0.0, 0.0, 0.0] :
          mass * diff / (L2(diff) * L2(diff) * L2(diff));
}

inline
double pow3(double x)
{
  return x * x * x;
}

inline
double[N, 3], double[N, 3]
advance(double[N, 3] positions, double[N, 3] velocities, double[N] masses,
        double dt)
{
  /* Why do I need to rename positions2? */
  positions2 = transpose(positions);
  accelerations = genarray([N, 3], 0d);

  for (i = 0; i < N; i++) {
    /* This needs to be lifted out manually, GCC also has trouble with it */
    ax = 0d;
    ay = 0d;
    az = 0d;
    for (j = 0; j < N; j++) {
      diffx = positions[0, i] - positions[0, j];
      diffy = positions[1, i] - positions[1, j];
      diffz = positions[2, i] - positions[2, j];
      n = pow3(sqrt(diffx * diffx + diffy * diffy + diffz * diffz));
      if (n != 0d) {
        diffx *= masses[j] / n;
        diffy *= masses[j] / n;
        diffz *= masses[j] / n;
        ax += diffx;
        ay += diffy;
        az += diffz;
      } 
    }
    accelerations[0, i] = ax;
    accelerations[1, i] = ay;
    accelerations[2, i] = az;
  }
//  accelerations = {[i] -> sum_outer({[j] -> accel([positions2[0, i] - positions2[0, j],
//                                                   positions2[1, i] - positions2[1, j],
//                                                   positions2[2, i] - positions2[2, j]],
//                                                  masses[j])
//                                         | [j] < [N]})
//                        | [i] < [N]};

  positions = transpose(positions2);

//  accelerations = {iv -> acceleration(positions[iv], positions, masses)
//                      | iv < [N]};
  velocities += accelerations * dt;
  positions += velocities * dt;

  return (positions, velocities);
}

int main()
{
    itime = getInterval("time", 1);
    start(itime);

    positions = {[i] -> [tod(i), tod(i), tod(i)] | [i] < [N]};
    velocities = genarray([N, 3], 0d);
    masses = {[i] -> 1d | [i] < [N]};

    for (t = 0; t < ITER; t++) {
      positions, velocities = advance(positions, velocities, masses, 0.01);
    }

    end(itime);

    fprintf(stderr, "Sum is %lf\n", sum(positions));

    time, unit = returnResultUnit(itime);
    fprintf(stderr, "This took %f%s.\n", time, unit);
    printf("%f\n", 
        (18.0 * tod(N) * tod(N) + 12.0 * tod(N)) * tod(ITER) / 1e9 / time);

    return 0;
}
