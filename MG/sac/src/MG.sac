/* FIXME Takes more than 10GB of memory to compile. Memory-leak? */

#define CLASS_S

#ifdef CLASS_S
#define N 32
#define ITER 4
#define ref 0.5307707005734e-4
#endif

#ifdef CLASS_W
#define N 128
#define ITER 4
#define ref 0.6467329375339e-5
#endif

#ifdef CLASS_A
#define N 256
#define ITER 4
#define ref 0.2433365309069e-5
#endif

#ifdef CLASS_B
#define N 256
#define ITER 20
#define ref 0.1800564401355e-5
#endif

#ifdef CLASS_C
#define N 512
#define ITER 20
#define ref 0.5706732285740e-6
#endif

#ifdef CLASS_D
#define N 1024
#define ITER 50
#define ref 0.1583275060440e-9
#endif

use Init: all;
use StdIO: all;
use Math: all;
use Array: all;

#define A(z) relax(z, gen_weights([-8d / 3d, 0d, 1d / 6d, 1d / 12d]))
#define P(z) relax(z, gen_weights([1d / 2d, 1d / 4d, 1d / 8d, 1d / 16d]))
#define Q(z) relax(z, gen_weights([1d, 1d / 2d, 1d / 4d, 1d / 8d]))
#define Sa(z) relax(z, gen_weights([-3d / 8d, 1d / 32d, -1d / 64d, 0d]))
#define Sb(z) relax(z, gen_weights([-3d / 17d, 1d / 33d, -1d / 61d, 0d]))

#if defined(CLASS_S) || defined(CLASS_W) || defined(CLASS_A)
  #define S(z) Sa(z)
#else
  #define S(z) Sb(z)
#endif

inline
double[.,.,.] relax(double[.,.,.] x, double[3, 3, 3] weights)
{
  return {iv -> sum({jv -> weights[jv] * rotate(1 - jv, x)[iv]})
             | iv < shape(x)};
}

inline
double[., ., .] gen_weights(double[4] cs)
{
  return {iv -> cs[sum(abs(iv - [1, 1, 1]))] | iv < [3, 3, 3]};
}

double[., ., .] residual(double[., ., .] v, double[., ., .] u)
{
  return v - A(u);
}

double[., ., .] M(double[., ., .] r)
{
  printf("Call m with shape [%d, %d, %d]\n",
          shape(r)[0], shape(r)[1], shape(r)[2]);
  r = P(r);
  r = {iv -> r[2 * iv + 1] | iv < shape(r) / 2};
  z = M(r);
  z = {iv -> z[(iv - 1) / 2] | [1, 1, 1] <= iv < 2 * shape(z) step [2, 2, 2];
       iv -> 0d              | [0, 0, 0] <= iv < 2 * shape(z) step [2, 2, 2]};
  z = Q(z);
  r = r - A(z);
  z = z + S(r);

  return z;
}

double[., ., .] M(double[2, 2, 2] r)
{
  printf("Call m with shape [%d, %d, %d]\n",
          shape(r)[0], shape(r)[1], shape(r)[2]);
  return S(r);
}

double[., ., .], double[., ., .], double[., ., .]
MG(double[., ., .] v, double[., ., .] u)
{
  r = residual(v, u);
  u += M(r);

  for (i = 1; i < ITER; i++) {
    r = residual(v, u);
    u += M(r);
  }

  return (v, u, r);
}

double L2(double[., ., .] r)
{
  return sqrt(sum(r) / prod(tod(shape(r))));
}

int main()
{
  u = {iv -> 0d | iv < [N, N, N]};
  v = init(N);

  v, u, r = MG(v, u);

  printf("Error: %lf\n", L2(r) - ref);
  return 0;
}
