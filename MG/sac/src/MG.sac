#ifdef CLASS_S
#define N 32
#define ITER 4
#define ref 0.5307707005734e-4
#endif

#ifdef CLASS_W
#define N 128
#define ITER 4
#define ref 0.6467329375339e-5
#endif

#ifdef CLASS_A
#define N 256
#define ITER 4
#define ref 0.2433365309069e-5
#endif

#ifdef CLASS_B
#define N 256
#define ITER 20
#define ref 0.1800564401355e-5
#endif

#ifdef CLASS_C
#define N 512
#define ITER 20
#define ref 0.5706732285740e-6
#endif

#ifdef CLASS_D
#define N 1024
#define ITER 50
#define ref 0.1583275060440e-9
#endif

use Input: all;
use StdIO: all;
use Math: all;
use Array: all except {rotate};
use Benchmarking: all;

#if defined(CLASS_S) || defined(CLASS_W) || defined(CLASS_A)
  #define S(z) Sa(z)
#else
  #define S(z) Sb(z)
#endif

inline
double[*] rotate(int[.] off, double[*] a)
{
  return {iv -> a[mod(iv-off, shape(a))] | iv < shape(a) };
}

inline
double[.,.,.] relax(double[.,.,.] x, double[3, 3, 3] weights)
{
  return {iv -> sum({jv -> weights[jv] * rotate(1 - jv, x)[iv]})
             | iv < shape(x)};
}

inline
double[.,.,.] gen_weights(double[4] cs)
{
  return {iv -> cs[sum(abs(iv - [1, 1, 1]))] | iv < [3, 3, 3]};
}

inline
double[*] coarse2fine(double[*] z)
{
  res = {iv -> z[(iv - 1) / 2] | [1, 1, 1] <= iv < 2 * shape(z) step [2, 2, 2] };
  return res;
}

inline
double[*] fine2coarse(double[*] r)
{
  return {iv -> r[2 * iv + 1] | iv < shape(r) / 2};
}

inline
double[.,.,.] A(double[.,.,.] a)
{
  return relax(a, gen_weights([-8d/3d, 0d, 1d/6d, 1d/12d]));
}

inline
double[.,.,.] P(double[.,.,.] a)
{
  return fine2coarse(relax(a, gen_weights([1d/2d, 1d/4d, 1d/8d, 1d/16d])));
}

inline
double[.,.,.] Q(double[.,.,.] a)
{
  return relax(coarse2fine (a), gen_weights([1d, 1d/2d, 1d/4d, 1d/8d]));
}

inline
double[.,.,.] Sa(double[.,.,.] a)
{
  return relax(a, gen_weights([-3d/8d, 1d/32d, -1d/64d, 0d]));
}

inline
double[.,.,.] Sb(double[.,.,.] a)
{
  return relax(a, gen_weights([-3d/17d, 1d/33d, -1d/61d, 0d]));
}

specialize double[1024,1024,1024] M (double[1024,1024,1024] r);
specialize double[512,512,512] M (double[512,512,512] r);
specialize double[256,256,256] M (double[256,256,256] r);
specialize double[128,128,128] M (double[128,128,128] r);
specialize double[64,64,64] M (double[64,64,64] r);
specialize double[32,32,32] M (double[32,32,32] r);
specialize double[16,16,16] M (double[16,16,16] r);
specialize double[8,8,8]    M (double[8,8,8] r);
specialize double[4,4,4]  M (double[4,4,4] r);
double[.,.,.] M(double[.,.,.] r)
{
  rs = P(r);
  zs = M(rs);
  z = Q(zs);
  r = r - A(z);
  z = z + S(r);

  return z;
}

double[2,2,2] M(double[2,2,2] r)
{
  return S(r);
}

double MG(double[N,N,N] v, double[N,N,N] u)
{
  for (i = 0; i < ITER; i++) {
    r = v - A(u);
    u = u + M(r);
  }

  return L2(v - A(u));
}

inline
double L2 (double[.,.,.] r)
{
  return sqrt(sum(r * r) / prod(tod(shape(r))));
}

int main()
{
  i_init = getInterval("init", 1);
  i_mg = getInterval("mg", 2);

  start(i_init);
  u = {iv -> 0d | iv < [N, N, N]};
  v = init(N);
  end(i_init);
  time, unit = returnResultUnit(i_init);
  printf("Initalisation took %f %s\n", time, unit);

  start(i_mg);
  r = MG(v, u);
  end(i_mg);
  time, unit = returnResultUnit(i_mg);
  printf("Calculation took %f %s\n", time, unit);
  printf("%f Mflops/%s\n",
      58d * tod(ITER) * tod(N) * tod(N) * tod(N) * 1e-6 / tod(time), unit);

  printf("Error: %.17e\n", abs(r - ref));
  return 0;
}
