use Array: all;
use Math: all;
use StdIO: all;
use Benchmarking: all;

#define REAL double
#define TO_REAL tod

/**
 * Initializes VarX as outer product of VarX1 and VarX2.
 */
REAL[.], REAL[.] updateParams(REAL[.] X,
                        REAL[.] Y,
                        REAL[.] Time,
                        int g,
                        REAL beta,
                        REAL nu)
{
  VarX1 = {[j] -> exp(2.0 * Y[j] - nu * nu * Time[g])};
  VarX2 = {[i] -> pow(X[i], 2.0 * beta)};

  return (VarX1, VarX2);
}

/**
 * Initializes indX, indY and X, Y, Time
 */
int, int, REAL[.], REAL[.], REAL[.] initGrid(int numX,
                                             int numY,
                                             int numT,
                                             REAL s0,
                                             REAL alpha,
                                             REAL nu,
                                             REAL t)
{
  Time = {[i] -> t * TO_REAL(i) / TO_REAL(numT - 1) | [i] < [numT]};
  stdX = 20.0 * alpha * s0 * sqrt(t);
  dx = stdX / TO_REAL(numX);
  indX = toi(s0 / dx);
  X = {[i] -> TO_REAL(i) * dx - TO_REAL(indX) * dx + s0 | [i] < [numX]};

  stdY = 10.0 * nu * sqrt(t);
  dy = stdY / TO_REAL(numY);
  indY = numY / 2;

  Y = {[i] -> TO_REAL(i) * dy - TO_REAL(indY) * dy + log(alpha)
            | [i] < [numY]};

  return (indX, indY, X, Y, Time);
}

/**
 * Initializes Globals:
 *      (i) Dxx when called with numX and X
 *     (ii) Dyy when called with numY and Y
 */
REAL[3] initDD(REAL dxl, REAL dxu)
{
  return [ 2.0 / dxl / (dxl + dxu),
          -2.0 * (1.0 / dxl + 1.0 / dxu) / (dxl + dxu),
           2.0 / dxu / (dxl + dxu)];
}

REAL[., .] initOperator(REAL[.] xx)
{
  n = shape(xx)[0];

  zero = [0.0, 0.0, 0.0];

  DD = {[i] -> zero
            | [0] <= [i] < [1];
        [i] -> initDD(xx[i] - xx[i - 1], xx[i + 1] - xx[i])
            | [1] <= [i] < [n - 1];
        [i] -> zero
            | [n - 1] <= [i] < [n]};

  return DD;
}

REAL[., .] setPayoff(int numX, /* = shape(X)[0] */
               int numY,
               REAL strike,
               REAL[.] X)
{
  return {[i, j] -> max(X[i] - strike, 0.0) | [i, j] < [numX, numY]};
}

/* TODO?: There exist parallel algorithms
   (https://dl.acm.org/doi/fullHtml/10.1145/3472456.3472484),
   but we call tridag in parallel as well.

   The parallelism is min(numX, numY) which is enough for CPU, but
   probably not enough for GPU. */
inline
REAL[.] tridag(REAL[.] a,
               REAL[.] b,
               REAL[.] c,
               REAL[.] y )
{
  n = shape(y)[0];

  /* This is the modified Thomas method from Numerical Methods.
   * Note that the non-zeroes in a row are a, b, c in this application,
   * and b, a, c in Numerical Methods.
   * We store gamma in b. */
  b[0] = 1.0 / b[0];
  y[0] = b[0] * y[0];

  for (i = 1; i < n; i++) {
      b[i] = 1.0 / (b[i] - a[i] * b[i - 1] * c[i - 1]);
      y[i] = b[i] * (y[i] - a[i] * y[i - 1]);
  }

  for (i = n - 2; i >= 0; i--) {
      y[i] = y[i] - b[i] * c[i] * y[i + 1];
  }

  return y;
}

specialize REAL[NUM_X] implicit_x(REAL VarX1, REAL[NUM_X] VarX2,
                                  REAL[NUM_X, 3] Dxx, REAL dtInv,
                                  REAL[NUM_X] uu);
REAL[.] implicit_x(REAL VarX1, REAL[.] VarX2, REAL[., .] Dxx,
                   REAL dtInv, REAL[.] uu)
{
  a = {[i] -> -0.25 * VarX1 * VarX2[i] * Dxx[i, 0]};
  b = {[i] -> dtInv - 0.25 * VarX1 * VarX2[i] * Dxx[i, 1]};
  c = {[i] -> -0.25 * VarX1 * VarX2[i] * Dxx[i, 2]};

  return tridag(a, b, c, uu);
}

/* Becomes slower for inlining */
specialize REAL[NUM_Y] implicit_y(REAL VarY, REAL[NUM_Y, 3] Dyy,
                              REAL dtInv, REAL[NUM_Y] yy);
REAL[.] implicit_y(REAL VarY, REAL[., .] Dyy, REAL dtInv, REAL[.] yy)
{
  a = {[j] -> -0.25 * VarY * Dyy[j, 0]};
  b = {[j] -> dtInv - 0.25 * VarY * Dyy[j, 1]};
  c = {[j] -> -0.25 * VarY * Dyy[j, 2]};

  return tridag(a, b, c, yy);
}

specialize REAL[NUM_X, NUM_Y] rollback(int g,
                    REAL[NUM_T] Time,
                    REAL[NUM_X, 3] Dxx, REAL[NUM_Y] VarX1, REAL[NUM_X] VarX2,
                    REAL[NUM_Y, 3] Dyy, REAL VarY,
                    REAL[NUM_X, NUM_Y] ResultE);
REAL[., .] rollback(int g,
                    REAL[.] Time,
                    REAL[., .] Dxx,
                    REAL[.] VarX1, REAL[.] VarX2,
                    REAL[., .] Dyy, REAL VarY,
                    REAL[., .] ResultE)
{
  dtInv = 1.0 / (Time[g + 1] - Time[g]);
  numX = shape(ResultE)[0];
  numY = shape(ResultE)[1];

  /* explicit x */
  U = {[j, i] -> dtInv * ResultE[i, j] + 0.25 *
                  sum({[k] -> ResultE[i - 1 + k, j] *
                              VarX1[j] * VarX2[i] * Dxx[i, k]
                            | [1] <= [k] < [3]})
               | [0, 0] <= [j, i] < [numY, 1];
       [j, i] -> dtInv * ResultE[i, j] + 0.25 *
                  sum({[k] -> ResultE[i - 1 + k, j] *
                              VarX1[j] * VarX2[i] * Dxx[i, k]
                            | [0] <= [k] < [3]})
               | [0, 1] <= [j, i] < [numY, numX - 1];
       [j, i] -> dtInv * ResultE[i, j] + 0.25 *
                  sum({[k] -> ResultE[i - 1 + k, j] *
                              VarX1[j] * VarX2[i] * Dxx[i, k]
                            | [0] <= [k] < [2]})
               | [0, numX - 1] <= [j, i] < [numY, numX]
       };

  /* explicit y */
  V = {[i, j] -> 0.5 * sum({[k] -> ResultE[i, j - 1 + k] * VarY * Dyy[j, k]
                                | [1] <= [k] < [3]})
               | [0, 0] <= [i, j] < [numX, 1];
       [i, j] -> 0.5 * sum({[k] -> ResultE[i, j - 1 + k] * VarY * Dyy[j, k]
                                 | [0] <= [k] < [3]})
               | [0, 1] <= [i, j] < [numX, numY - 1];
        [i, j] -> 0.5 * sum({[k] -> ResultE[i, j - 1 + k] * VarY * Dyy[j, k]
                                  | [0] <= [k] < [2]})
               | [0, numY - 1] <= [i, j] < [numX, numY]
      };

  U = {[j, i] -> U[j, i] + V[i, j]};

  /* implicit x */
  U = {[j] -> implicit_x(VarX1[j], VarX2, Dxx, dtInv, U[j])};

  /* implicit y */
  ResultE = {[i] -> implicit_y(VarY, Dyy, dtInv,
                      {[j] -> dtInv * U[j, i] - V[i, j] / 2.0})};

  return ResultE;
}

REAL value(REAL s0,
           REAL strike,
           REAL t,
           REAL alpha,
           REAL nu,
           REAL beta,
           int numX,
           int numY,
           int numT)
{
  indX, indY, X, Y, Time = initGrid(numX, numY, numT, s0, alpha, nu, t);

  Dxx = initOperator(X);
  Dyy = initOperator(Y);

  ResultE = setPayoff(numX, numY, strike, X);

  for (i = numT - 2; i >= 0; i--) {
    VarX1, VarX2 = updateParams(X, Y, Time, i, beta, nu);

    ResultE = rollback(i, Time,
                       Dxx, VarX1, VarX2,
                       Dyy, nu * nu,
                       ResultE);
  }

  return ResultE[indX, indY];
}

int main()
{
    fprintf(stdout, "\n// SaC Volatility Calibration Benchmark:\n");

    itime = getInterval("time", 1);
    start(itime);
    result = {[i] -> value(S0, TO_REAL(i) / 1000.0, T, ALPHA, NU, BETA,
                           NUM_X, NUM_Y, NUM_T) | [i] < [OUTER]};
    end(itime);
    print(result);

    time, unit = returnResultUnit(itime);
    printf("This took %f%s.\n", time, unit);

    return 0;
}
